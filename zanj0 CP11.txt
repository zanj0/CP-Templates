/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

template <class T>
using ordered_set =  __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;

#define LOCAL
#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18
#define ps(x,y)         fixed<<setprecision(y)<<x
#define w(x)            int x; cin>>x; while(x--)
#define endl       		"\n"
#define timetaken cerr<<"Time : "<<1000*(long double)clock()/(long double)CLOCKS_PER_SEC<<"ms\n"

typedef long long int lli;

// -----------------------------------------------------------------------------
// ðŸ§  THINKING SCAFFOLD
// -----------------------------------------------------------------------------
/*
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    THINKING SCAFFOLD (use this as mental scratchpad before coding)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Problem Statement:
    â€¢ (1â€“2 lines) What is being asked? What are input/output formats?


    Constraints:
    â€¢ n â‰¤ ?, m â‰¤ ?, time/memory limits?
    â€¢ Sum over tests? Special structure (tree, grid, mod)?

    Small Observations:
    â€¢ Trivial / base cases.
    â€¢ Parity, ordering, prefix/suffix, symmetry, invariants.

    Key Reformulation:
    â€¢ Can problem be viewed as prefix-sum / graph / DP / greedy / math?
    â€¢ Any â€œturnsâ€ / â€œstate transitionsâ€ pattern?

    Approach Sketch:
    â€¢ Step 1 â†’ Step 2 â†’ Step 3 (brief flow)
    â€¢ What structure is core? (array / set / heap / segment tree / etc.)
    â€¢ Why it works (1â€“2 bullet â€œproof ideasâ€)

    Edge Cases:
    â€¢ n=1, all equal, strictly inc/dec, overflow, modulo, sign, etc.

    Complexity:
    â€¢ Time: O( â€¦ )   Space: O( â€¦ )

    Implementation Plan:
    â€¢ Variables and main data structures.
    â€¢ Loops / recursion depth / modulo handling.

    Test Plan:
    â€¢ Minimal (n=1, small)
    â€¢ Borderline (max constraints)
    â€¢ Random sanity
    â€¢ Adversarial (sorted, reverse, alternating)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*/


// -----------------------------------------------------------------------------
// ðŸ§© UTILITY HELPERS
// -----------------------------------------------------------------------------
template<typename T> inline bool ckmin(T &a, const T &b){ if(b < a){ a = b; return true; } return false; }
template<typename T> inline bool ckmax(T &a, const T &b){ if(a < b){ a = b; return true; } return false; }

template<typename T>
T binpow(T a, long long e, T mod = (T)MOD){
    T r = 1 % mod; a %= mod;
    while(e){
        if(e & 1) r = (r * a) % mod;
        a = (a * a) % mod;
        e >>= 1;
    }
    return r;
}

#ifdef LOCAL
    #define dbg(x) cerr << "[DBG] " << #x << " = " << (x) << '\n'
    template<class A, class B>
    ostream& operator<<(ostream& os, const pair<A,B>& p){ return os << '(' << p.first << ',' << p.second << ')'; }
    template<class T>
    ostream& operator<<(ostream& os, const vector<T>& v){ os << '['; for(size_t i=0;i<v.size();++i){ if(i) os << (i?',':' '); os << v[i]; } return os << ']'; }
#else
    #define dbg(x) ((void)0)
#endif


// -----------------------------------------------------------------------------
// âš™ï¸ I/O BOOTSTRAP
// -----------------------------------------------------------------------------
void zanj0()
{
	ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
#endif
}


// -----------------------------------------------------------------------------
// ðŸš€ SOLUTION FUNCTION
// -----------------------------------------------------------------------------
void Solve(){
    /*
        Implementation Notes:
        ---------------------
        1. Read inputs.
        2. Apply transformations / precomputations.
        3. Implement main logic.
        4. Output the result.
    */

   
}


// -----------------------------------------------------------------------------
// ðŸ MAIN DRIVER
// -----------------------------------------------------------------------------
int32_t main()
{
	zanj0();

    // For multiple test cases:
    // w(t) Solve();

    // For single test case:
    // Solve();

	timetaken;
	return 0;
}


/*
    GOLDEN RULES
    â€¢ Solutions are simple.
    â€¢ Proofs are simple.
    â€¢ Implementations are simple.
*/
